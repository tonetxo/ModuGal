---
import { getLangFromUrl, useTranslations } from "../i18n/utils";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const images = [
  {
    src: "/assets/hero-image-1.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Vista principal",
  },
  {
    src: "/assets/hero-image-2.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Detalle del oscilador",
  },
  {
    src: "/assets/hero-image-3.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Matriz de modulación",
  },
];
---

<div class="main-grid">
  <svg id="sine-wave-svg" class="background-wave">
    <path id="sine-wave-path-1"></path>
    <path id="sine-wave-path-2"></path>
  </svg>

  <div class="knob-area">
    <h4 class="knob-label" data-i18n-key="knob.menu">{t("knob.menu")}</h4>
    <div id="nav-knob" class="knob">
      <div class="knob-base"></div>
      <div class="knob-ring"><div class="knob-indicator"></div></div>
      <div class="knob-center"></div>
    </div>
  </div>

  <main>
    <div class="container">
      <header>
        <h1>ModuGal</h1>
        <h2 data-i18n-key="header.subtitle">{t("header.subtitle")}</h2>
      </header>
      <div class="slideshow-container">
        {
          images.map((image, index) => (
            <img
              src={image.src}
              alt={image.alt}
              class={`slideshow-image ${index === 0 ? "visible" : ""}`}
            />
          ))
        }
      </div>
      <div class="content">
        <p class="tagline" data-i18n-key="tagline">
          {t("tagline")}
        </p>
        <div class="cta-buttons">
          <a href="#" class="button primary" data-i18n-key="button.buy"
            >{t("button.buy")}</a
          >
          <a href="#" class="button secondary" data-i18n-key="button.demo"
            >{t("button.demo")}</a
          >
        </div>
      </div>
    </div>
  </main>

  <div class="menu-title-area">
    <h3 id="menu-title-display"></h3>
  </div>
</div>

<style>
  .main-grid {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    align-items: center;
    justify-items: center;
    width: 100%;
    min-height: 100vh;
    padding: 2rem;
    box-sizing: border-box;
    position: relative;
  }
  .background-wave {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }
  #sine-wave-path-1,
  #sine-wave-path-2 {
    fill: none;
    stroke: var(--color-accent-1);
    stroke-width: 2;
    stroke-opacity: 0.6;
    filter: drop-shadow(0 0 5px var(--color-accent-1));
  }
  .knob-area,
  main,
  .menu-title-area {
    position: relative;
    z-index: 1;
  }
  .knob-area {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    width: 100%;
    height: 100%;
    transform: translateY(-40px);
  }
  .menu-title-area {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
  }
  main {
    width: 100%;
    max-width: 700px;
  }
  .container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  header {
    margin-bottom: 2rem;
  }
  h1 {
    font-family: "Castelao", var(--font-family-headings);
    font-size: 5rem;
    line-height: 1;
    margin-bottom: 0.5rem;
  }
  h2 {
    font-size: 1.5rem;
    font-family: var(--font-family-body);
    color: var(--color-text);
    font-weight: 400;
  }
  .knob-label {
    font-family: var(--font-family-headings);
    color: var(--color-accent-1);
    font-size: 1.8rem;
    margin: 0;
    text-shadow: 0 0 5px var(--color-accent-1);
  }
  .knob {
    position: relative;
    width: 150px;
    height: 150px;
    cursor: ns-resize;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .knob-base {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 50% 50%,
      #8c5a2d 0%,
      #593a1c 100%
    );
    box-shadow:
      inset 0 0 20px rgba(0, 0, 0, 0.7),
      0 5px 15px rgba(0, 0, 0, 0.5);
  }
  .knob-ring {
    position: absolute;
    width: 80%;
    height: 80%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 50% 50%,
      #3d3d3d 0%,
      #1a1a1a 100%
    );
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.8),
      0 2px 5px rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    transition: transform 0.1s linear;
  }
  .knob-center {
    position: absolute;
    width: 40%;
    height: 40%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 30% 30%,
      #e0e0e0 0%,
      #8c8c8c 100%
    );
    box-shadow:
      inset 0 0 5px rgba(255, 255, 255, 0.5),
      0 0 10px rgba(0, 0, 0, 0.5);
  }
  .knob-indicator {
    position: absolute;
    width: 4px;
    height: 15px;
    background-color: var(--color-accent-2);
    top: 0;
    transform: translateY(-5px);
    border-radius: 2px;
    box-shadow: 0 0 5px var(--color-accent-2);
  }
  .menu-title-area h3 {
    font-size: 2.5rem;
    color: var(--color-accent-1);
    text-shadow: 0 0 10px var(--color-accent-1);
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  .menu-title-area h3.visible {
    opacity: 1;
    cursor: pointer;
  }
  .slideshow-container {
    display: grid;
    width: 100%;
    margin: auto;
    border: 3px solid var(--color-accent-1);
    border-radius: 4px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    overflow: hidden;
    cursor: grab;
  }
  .slideshow-container.grabbing {
    cursor: grabbing;
  }
  .slideshow-image {
    grid-area: 1 / 1 / 2 / 2;
    width: 100%;
    height: 100%;
    object-fit: contain;
    opacity: 0;
    transition: opacity 0.75s ease-in-out;
    visibility: hidden;
    transform-origin: center center;
  }
  .slideshow-image.visible {
    opacity: 1;
    visibility: visible;
  }
  .content {
    margin-top: 2rem;
  }
  .tagline {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: var(--color-text);
    min-height: 3em;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .cta-buttons {
    display: flex;
    justify-content: center;
    gap: 1rem;
  }
  .button {
    display: inline-block;
    padding: 0.8rem 1.5rem;
    border-radius: 4px;
    text-decoration: none;
    font-weight: 600;
    font-family: var(--font-family-body);
    transition: all 0.3s ease;
    border: 2px solid transparent;
  }
  .button.primary {
    background-color: var(--color-accent-1);
    color: var(--color-base);
    border-color: var(--color-accent-1);
  }
  .button.primary:hover {
    background-color: transparent;
    color: var(--color-accent-1);
  }
  .button.secondary {
    background-color: transparent;
    color: var(--color-accent-2);
    border-color: var(--color-accent-2);
  }
  .button.secondary:hover {
    background-color: var(--color-accent-2);
    color: var(--color-base);
  }
  .knob-center.flash {
    animation: flash-effect 0.4s ease-out;
  }
  @keyframes flash-effect {
    0% {
      box-shadow:
        inset 0 0 5px rgba(255, 255, 255, 0.5),
        0 0 10px rgba(0, 0, 0, 0.5);
    }
    50% {
      box-shadow:
        inset 0 0 10px rgba(255, 255, 255, 0.8),
        0 0 25px var(--color-accent-2),
        0 0 15px white;
    }
    100% {
      box-shadow:
        inset 0 0 5px rgba(255, 255, 255, 0.5),
        0 0 10px rgba(0, 0, 0, 0.5);
    }
  }

  /* ===== RESPONSIVE MÓVILES ===== */
  @media (max-width: 768px) {
    .main-grid {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
      gap: 1.5rem;
      padding: 1rem;
      padding-top: 4rem; /* Espacio para controles de navegación */
      min-height: auto;
      align-items: start;
    }
    .knob-area {
      order: 2;
      transform: none;
      flex-direction: row;
      gap: 1rem;
    }
    main {
      order: 1;
    }
    .menu-title-area {
      order: 3;
    }
    .menu-title-area h3 {
      writing-mode: horizontal-tb;
      transform: none;
      font-size: 1.8rem;
    }
    h1 {
      font-size: 3.5rem;
    }
    h2 {
      font-size: 1.2rem;
    }
    .knob {
      width: 100px;
      height: 100px;
    }
    .knob-label {
      font-size: 1.3rem;
    }
    .knob-indicator {
      height: 10px;
    }
    .tagline {
      font-size: 1rem;
      min-height: 2.5em;
    }
    .button {
      padding: 0.7rem 1.2rem;
      font-size: 0.9rem;
    }
    .slideshow-container {
      max-width: 100%;
    }
  }

  @media (max-width: 480px) {
    .main-grid {
      padding: 0.75rem;
      padding-top: 3.5rem;
      gap: 1rem;
    }
    h1 {
      font-size: 2.5rem;
    }
    h2 {
      font-size: 1rem;
    }
    .knob {
      width: 80px;
      height: 80px;
    }
    .knob-label {
      font-size: 1.1rem;
    }
    .knob-indicator {
      height: 8px;
      width: 3px;
    }
    .cta-buttons {
      flex-direction: column;
      gap: 0.75rem;
    }
    .button {
      width: 100%;
      text-align: center;
    }
    .menu-title-area h3 {
      font-size: 1.4rem;
    }
    .tagline {
      font-size: 0.9rem;
    }
  }
</style>

<script>
  import { ui, defaultLang } from "../i18n/ui";
  import { navigate } from "astro:transitions/client";

  // Cleanup controller
  let windowEventsController: AbortController | null = null;

  function initHomePage() {
    // Cleanup previous listeners
    if (windowEventsController) {
      windowEventsController.abort();
    }
    windowEventsController = new AbortController();
    const windowSignal = windowEventsController.signal;

    document.body.classList.remove("uninitialized");

    // --- DOM Elements ---
    const svg = document.getElementById(
      "sine-wave-svg",
    ) as SVGSVGElement | null;
    const sinePath1 = document.getElementById(
      "sine-wave-path-1",
    ) as SVGPathElement | null;
    const sinePath2 = document.getElementById(
      "sine-wave-path-2",
    ) as SVGPathElement | null;
    const knob = document.getElementById("nav-knob");
    const menuTitleDisplay = document.getElementById("menu-title-display");

    // --- State ---
    let peakAmplitude = 0;

    // Detect language from URL path
    const pathMatch = window.location.pathname.match(/^\/([a-z]{2})/);
    const currentLang = pathMatch ? pathMatch[1] : defaultLang;

    // Knob starts at 0 every time
    let currentAngle = 0;

    let blipOsc: OscillatorNode | null = null;
    let blipGain: GainNode | null = null;

    // Build dynamic paths - Handle root path correctly
    // If currentLang is 'gl', we might be at '/' or '/gl/'.
    // We strictly use /gl/, /es/, /en/ prefixes for consistency.
    const pathPrefix = `/${currentLang}`;

    const menuItems = [
      { nameKey: "nav.home", path: `${pathPrefix}/`, freq: 261.63 },
      { nameKey: "nav.modules", path: `${pathPrefix}/modulos`, freq: 329.63 },
      { nameKey: "nav.demos", path: `${pathPrefix}/demos`, freq: 392.0 },
      { nameKey: "nav.support", path: `${pathPrefix}/soporte`, freq: 440.0 },
    ];

    // --- Audio Functions ---
    function initAudioContext() {
      if (window.audioContext) return;
      try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audioContext = new AudioContext();
      } catch (e) {
        console.error("Web Audio API not supported", e);
      }
    }

    function setupBlip() {
      if (!window.audioContext || blipOsc) return;
      blipOsc = window.audioContext.createOscillator();
      blipGain = window.audioContext.createGain();
      blipGain.gain.value = 0;
      blipOsc.connect(blipGain).connect(window.audioContext.destination);
      blipOsc.start();
    }

    function playMenuBlip(freq = 440) {
      if (!window.audioContext || !blipOsc || !blipGain) return;
      const ctx = window.audioContext;
      const now = ctx.currentTime;
      blipOsc.frequency.cancelScheduledValues(now);
      blipOsc.frequency.setValueAtTime(freq, now);
      blipGain.gain.cancelScheduledValues(now);
      blipGain.gain.setValueAtTime(0.2, now);
      blipGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    }

    // --- Visuals ---
    function updateSineWaves() {
      if (!sinePath1 || !sinePath2 || !svg) return;

      const svgWidth = svg.clientWidth;
      const svgHeight = svg.clientHeight;
      const yOffset = svgHeight / 2;

      if (currentAngle < 5) {
        sinePath1.setAttribute("d", "");
        sinePath2.setAttribute("d", "");
        return;
      }

      const baseAmplitude = 30;
      const totalAmplitude = baseAmplitude + peakAmplitude;
      const frequency = 0.05;
      const vibratoFrequency = 0.4;
      const currentVibratoAmplitude = (peakAmplitude / 50) * 8;
      const startLeft = svgWidth * 0.24;
      const startRight = svgWidth * 0.75;
      const waveLength = startLeft * 0.95 * (currentAngle / 270);

      let pathData1 = `M ${startLeft} ${yOffset}`;
      let pathData2 = `M ${startRight} ${yOffset}`;

      for (let x = 0; x <= waveLength; x++) {
        const mainWave = Math.sin(x * frequency) * totalAmplitude;
        const vibrato =
          Math.sin(x * vibratoFrequency) * currentVibratoAmplitude;
        const y = yOffset + mainWave + vibrato;
        pathData1 += ` L ${startLeft - x} ${y}`;
        pathData2 += ` L ${startRight + x} ${y}`;
      }

      sinePath1.setAttribute("d", pathData1);
      sinePath2.setAttribute("d", pathData2);
    }

    function decayPeak() {
      if (peakAmplitude > 0) {
        peakAmplitude = Math.max(0, peakAmplitude - 2.5);
        updateSineWaves();
        requestAnimationFrame(decayPeak);
      }
    }

    // --- Interaction ---
    if (knob) {
      const knobCenter = knob.querySelector(".knob-center");
      const knobRing = knob.querySelector(".knob-ring") as HTMLElement;

      let isDraggingKnob = false;
      let startY = 0;
      let lastAngle = currentAngle;
      let selectedIndex = 0;

      // Force initial visual update with restored angle
      if (knobRing) knobRing.style.transform = `rotate(${currentAngle}deg)`;

      function updateMenu() {
        const totalItems = menuItems.length;
        const anglePerItem = 270 / (totalItems - 1);
        const newIndex = Math.round(currentAngle / anglePerItem);
        const safeIndex = Math.max(0, Math.min(totalItems - 1, newIndex));

        if (safeIndex !== selectedIndex) {
          playMenuBlip(menuItems[safeIndex].freq);
          peakAmplitude = 50;
          decayPeak();
          if (knobCenter) {
            knobCenter.classList.remove("flash");
            void (knobCenter as HTMLElement).offsetWidth;
            knobCenter.classList.add("flash");
          }
        }
        selectedIndex = safeIndex;

        if (menuTitleDisplay) {
          const nameKey = menuItems[selectedIndex].nameKey;
          // Robust text fallback
          let text = nameKey;
          if (ui[currentLang] && ui[currentLang][nameKey]) {
            text = ui[currentLang][nameKey];
          } else if (ui["gl"] && ui["gl"][nameKey]) {
            text = ui["gl"][nameKey];
          }

          menuTitleDisplay.textContent = text;
          menuTitleDisplay.classList.toggle("visible", nameKey !== "nav.home");
        }
      }

      function navigateToSelected() {
        const targetPath = menuItems[selectedIndex].path;

        // Prevent navigation loop if we are already there
        if (
          window.location.pathname !== targetPath &&
          window.location.pathname + "/" !== targetPath
        ) {
          navigate(targetPath);
        }
      }

      // Mouse Events (Linear Drag Logic)
      knob.addEventListener("mousedown", (e) => {
        e.preventDefault();
        isDraggingKnob = true;
        startY = e.clientY;
        lastAngle = currentAngle;
        if (window.audioController) window.audioController.startEngine();
        if (!blipOsc) setupBlip();
        if (knobRing) knobRing.style.transition = "none";
      });

      window.addEventListener(
        "mousemove",
        (e) => {
          if (!isDraggingKnob) return;
          const deltaY = e.clientY - startY;
          // Linear calculation based on vertical drag
          currentAngle = Math.max(0, Math.min(270, lastAngle - deltaY * 1.5));

          if (knobRing) knobRing.style.transform = `rotate(${currentAngle}deg)`;
          updateMenu();
          updateSineWaves();
        },
        { signal: windowSignal },
      );

      window.addEventListener(
        "mouseup",
        () => {
          if (!isDraggingKnob) return;
          isDraggingKnob = false;
          if (knobRing) knobRing.style.transition = "transform 0.1s linear";

          // Navigate on release if we dragged
          navigateToSelected();
        },
        { signal: windowSignal },
      );

      // Touch Events (Linear Drag Logic)
      knob.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          isDraggingKnob = true;
          startY = e.touches[0].clientY;
          lastAngle = currentAngle;
          if (window.audioController) window.audioController.startEngine();
          if (!blipOsc) setupBlip();
          if (knobRing) knobRing.style.transition = "none";
        },
        { passive: false },
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (!isDraggingKnob) return;
          e.preventDefault();
          const deltaY = e.touches[0].clientY - startY;
          // Linear calculation
          currentAngle = Math.max(0, Math.min(270, lastAngle - deltaY * 1.5));

          if (knobRing) knobRing.style.transform = `rotate(${currentAngle}deg)`;
          updateMenu();
          updateSineWaves();
        },
        { passive: false, signal: windowSignal },
      );

      window.addEventListener(
        "touchend",
        () => {
          if (!isDraggingKnob) return;
          isDraggingKnob = false;
          if (knobRing) knobRing.style.transition = "transform 0.1s linear";

          // Navigate on release
          navigateToSelected();
        },
        { signal: windowSignal },
      );

      // Click to Navigate (for single clicks without drag)
      knob.addEventListener("click", () => {
        // If we just clicked without dragging (or very little), navigate too
        // Note: mouseup/touchend handles dragging release. This handles pure clicks.
        // We use a small timeout to avoid double navigation if mouseup already fired?
        // Actually, if mouseup fired, it navigated.
        // We can check if we already navigated?
        // Simpler: let mouseup handle everything related to the knob interaction.
      });

      if (menuTitleDisplay && menuTitleDisplay.parentElement) {
        menuTitleDisplay.parentElement.addEventListener("click", () => {
          navigateToSelected();
        });
      }

      // Initial Render
      updateMenu();
      updateSineWaves();
    }

    // --- Slideshow Logic ---
    const slideshowContainer = document.querySelector(".slideshow-container");
    if (slideshowContainer) {
      const images = slideshowContainer.querySelectorAll(
        ".slideshow-image",
      ) as NodeListOf<HTMLElement>;
      let currentIndex = 0;
      let interval: ReturnType<typeof setInterval>;
      let scale = 1;
      let panning = false;
      let start = { x: 0, y: 0 };
      let transform = { x: 0, y: 0 };

      if (images.length > 0) {
        function applyTransform(el: HTMLElement) {
          el.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${scale})`;
        }

        function resetState() {
          scale = 1;
          panning = false;
          start = { x: 0, y: 0 };
          transform = { x: 0, y: 0 };
        }

        slideshowContainer.addEventListener("mousedown", (e) => {
          const evt = e as MouseEvent;
          evt.preventDefault();
          panning = true;
          start = {
            x: evt.clientX - transform.x,
            y: evt.clientY - transform.y,
          };
          slideshowContainer.classList.add("grabbing");
          stopSlideshow();
        });

        window.addEventListener(
          "mousemove",
          (e) => {
            if (!panning || scale === 1) return;
            const evt = e as MouseEvent;
            evt.preventDefault();
            transform.x = evt.clientX - start.x;
            transform.y = evt.clientY - start.y;
            applyTransform(images[currentIndex]);
          },
          { signal: windowSignal },
        );

        window.addEventListener(
          "mouseup",
          () => {
            if (panning) {
              panning = false;
              slideshowContainer.classList.remove("grabbing");
              startSlideshow();
            }
          },
          { signal: windowSignal },
        );

        slideshowContainer.addEventListener("wheel", (e) => {
          const evt = e as WheelEvent;
          evt.preventDefault();
          const delta = evt.deltaY > 0 ? -0.1 : 0.1;
          scale = Math.max(1, Math.min(scale + delta, 5));
          if (scale === 1) transform = { x: 0, y: 0 };
          applyTransform(images[currentIndex]);
        });

        function advance() {
          if (images[currentIndex]) {
            images[currentIndex].style.transform = "";
            images[currentIndex].classList.remove("visible");
          }
          resetState();
          currentIndex = (currentIndex + 1) % images.length;
          if (images[currentIndex]) {
            images[currentIndex].classList.add("visible");
            applyTransform(images[currentIndex]);
          }
        }

        function startSlideshow() {
          stopSlideshow();
          interval = setInterval(advance, 3000);
        }

        function stopSlideshow() {
          clearInterval(interval);
        }

        startSlideshow();
      }
    }
  }

  // --- Initialize ---
  document.addEventListener("astro:page-load", initHomePage);
  initHomePage();
</script>

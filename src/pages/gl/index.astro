---
import Layout from '../../layouts/Layout.astro';
import { getLangFromUrl, useTranslations } from '../../i18n/utils';

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const images = [
  {
    src: "/assets/hero-image-1.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Vista principal",
  },
  {
    src: "/assets/hero-image-2.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Detalle del oscilador",
  },
  {
    src: "/assets/hero-image-3.png",
    alt: "Captura de pantalla del sintetizador ModuGal - Matriz de modulación",
  },
];
---

<Layout title={t('page.title')}>
  <div class="main-grid">
    <svg id="sine-wave-svg" class="background-wave">
      <path id="sine-wave-path-1"></path>
      <path id="sine-wave-path-2"></path>
    </svg>

    <div class="knob-area">
      <h4 class="knob-label" data-i18n-key="knob.menu">{t('knob.menu')}</h4>
      <div id="nav-knob" class="knob">
        <div class="knob-base"></div>
        <div class="knob-ring"><div class="knob-indicator"></div></div>
        <div class="knob-center"></div>
      </div>
    </div>

    <main>
      <div class="container">
        <header>
          <h1>ModuGal</h1>
          <h2 data-i18n-key="header.subtitle">{t('header.subtitle')}</h2>
        </header>
        <div class="slideshow-container">
          {
            images.map((image, index) => (
              <img
                src={image.src}
                alt={image.alt}
                class={`slideshow-image ${index === 0 ? "visible" : ""}`}
              />
            ))
          }
        </div>
        <div class="content">
          <p class-="tagline" data-i18n-key="tagline">
            {t('tagline')}
          </p>
          <div class="cta-buttons">
            <a href="#" class="button primary" data-i18n-key="button.buy"
              >{t('button.buy')}</a
            >
            <a href="#" class="button secondary" data-i18n-key="button.demo"
              >{t('button.demo')}</a
            >
          </div>
        </div>
      </div>
    </main>

    <div class="menu-title-area">
      <h3 id="menu-title-display"></h3>
    </div>
  </div>
</Layout>

<style>
  .main-grid {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    align-items: center;
    justify-items: center;
    width: 100%;
    min-height: 100vh;
    padding: 2rem;
    box-sizing: border-box;
    position: relative;
  }
  .background-wave {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }
  #sine-wave-path-1,
  #sine-wave-path-2 {
    fill: none;
    stroke: var(--color-accent-1);
    stroke-width: 2;
    stroke-opacity: 0.6;
    filter: drop-shadow(0 0 5px var(--color-accent-1));
  }
  .knob-area,
  main,
  .menu-title-area {
    position: relative;
    z-index: 1;
  }
  .knob-area {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    width: 100%;
    height: 100%;
    transform: translateY(-40px);
  }
  .menu-title-area {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
  }
  main {
    width: 100%;
    max-width: 700px;
  }
  .container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  header {
    margin-bottom: 2rem;
  }
  h1 {
    font-family: "Castelao", var(--font-family-headings);
    font-size: 5rem;
    line-height: 1;
    margin-bottom: 0.5rem;
  }
  h2 {
    font-size: 1.5rem;
    font-family: var(--font-family-body);
    color: var(--color-text);
    font-weight: 400;
  }
  .knob-label {
    font-family: var(--font-family-headings);
    color: var(--color-accent-1);
    font-size: 1.8rem;
    margin: 0;
    text-shadow: 0 0 5px var(--color-accent-1);
  }
  .knob {
    position: relative;
    width: 150px;
    height: 150px;
    cursor: ns-resize;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .knob-base {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 50% 50%,
      #8c5a2d 0%,
      #593a1c 100%
    );
    box-shadow:
      inset 0 0 20px rgba(0, 0, 0, 0.7),
      0 5px 15px rgba(0, 0, 0, 0.5);
  }
  .knob-ring {
    position: absolute;
    width: 80%;
    height: 80%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 50% 50%,
      #3d3d3d 0%,
      #1a1a1a 100%
    );
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.8),
      0 2px 5px rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    transition: transform 0.1s linear;
  }
  .knob-center {
    position: absolute;
    width: 40%;
    height: 40%;
    border-radius: 50%;
    background-image: radial-gradient(
      circle at 30% 30%,
      #e0e0e0 0%,
      #8c8c8c 100%
    );
    box-shadow:
      inset 0 0 5px rgba(255, 255, 255, 0.5),
      0 0 10px rgba(0, 0, 0, 0.5);
  }
  .knob-indicator {
    position: absolute;
    width: 4px;
    height: 15px;
    background-color: var(--color-accent-2);
    top: 0;
    transform: translateY(-5px);
    border-radius: 2px;
    box-shadow: 0 0 5px var(--color-accent-2);
  }
  .menu-title-area h3 {
    font-size: 2.5rem;
    color: var(--color-accent-1);
    text-shadow: 0 0 10px var(--color-accent-1);
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  .menu-title-area h3.visible {
    opacity: 1;
  }
  .slideshow-container {
    display: grid;
    width: 100%;
    margin: auto;
    border: 3px solid var(--color-accent-1);
    border-radius: 4px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    overflow: hidden;
    cursor: grab;
  }
  .slideshow-container.grabbing {
    cursor: grabbing;
  }
  .slideshow-image {
    grid-area: 1 / 1 / 2 / 2;
    width: 100%;
    height: 100%;
    object-fit: contain;
    opacity: 0;
    transition: opacity 0.75s ease-in-out;
    visibility: hidden;
    transform-origin: center center;
  }
  .slideshow-image.visible {
    opacity: 1;
    visibility: visible;
  }
  .content {
    margin-top: 2rem;
  }
  .tagline {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: var(--color-text);
    min-height: 3em;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .cta-buttons {
    display: flex;
    justify-content: center;
    gap: 1rem;
  }
  .button {
    display: inline-block;
    padding: 0.8rem 1.5rem;
    border-radius: 4px;
    text-decoration: none;
    font-weight: 600;
    font-family: var(--font-family-body);
    transition: all 0.3s ease;
    border: 2px solid transparent;
  }
  .button.primary {
    background-color: var(--color-accent-1);
    color: var(--color-base);
    border-color: var(--color-accent-1);
  }
  .button.primary:hover {
    background-color: transparent;
    color: var(--color-accent-1);
  }
  .button.secondary {
    background-color: transparent;
    color: var(--color-accent-2);
    border-color: var(--color-accent-2);
  }
  .button.secondary:hover {
    background-color: var(--color-accent-2);
    color: var(--color-base);
  }
  .knob-center.flash {
    animation: flash-effect 0.4s ease-out;
  }
  @keyframes flash-effect {
    0% {
      box-shadow:
        inset 0 0 5px rgba(255, 255, 255, 0.5),
        0 0 10px rgba(0, 0, 0, 0.5);
    }
    50% {
      box-shadow:
        inset 0 0 10px rgba(255, 255, 255, 0.8),
        0 0 25px var(--color-accent-2),
        0 0 15px white;
    }
    100% {
      box-shadow:
        inset 0 0 5px rgba(255, 255, 255, 0.5),
        0 0 10px rgba(0, 0, 0, 0.5);
    }
  }
</style>

<script>
  import { ui, defaultLang } from "../../i18n/ui";

  // --- Cleanup function to remove old event listeners ---
  function cleanupHomePage() {
    // We'll add cleanup logic here if needed in the future,
    // for now, re-running init is handled by the page-load event.
  }

  function initHomePage() {
    document.body.classList.remove('uninitialized');
    // --- Global State & Elements ---
    const svg = document.getElementById(
      "sine-wave-svg"
    ) as SVGSVGElement | null;
    const sinePath1 = document.getElementById(
      "sine-wave-path-1"
    ) as SVGPathElement | null;
    const sinePath2 = document.getElementById(
      "sine-wave-path-2"
    ) as SVGPathElement | null;
    let peakAmplitude = 0;
    let currentAngle = 0;
    let blipOsc: OscillatorNode | null = null;
    let blipGain: GainNode | null = null;
    let currentLang = defaultLang;

    // --- Sine Wave Logic ---
    function updateSineWaves() {
      if (!sinePath1 || !sinePath2 || !svg) return;

      const svgWidth = svg.clientWidth;
      const svgHeight = svg.clientHeight;
      const yOffset = svgHeight / 2;

      // Si el knob está a cero, vaciamos las ondas y terminamos.
      if (currentAngle < 5) {
        // Pequeño umbral para que no desaparezca inmediatamente
        sinePath1.setAttribute("d", "");
        sinePath2.setAttribute("d", "");
        return;
      }

      // Parámetros de la forma de la onda
      const baseAmplitude = 30;
      const totalAmplitude = baseAmplitude + peakAmplitude;
      const frequency = 0.05;
      const vibratoFrequency = 0.4;
      const currentVibratoAmplitude = (peakAmplitude / 50) * 8;

      // Puntos de inicio de las ondas (izquierda y derecha)
      const startLeft = svgWidth * 0.24;
      const startRight = svgWidth * 0.75;

      // La longitud de la onda ahora se calcula en base al giro del knob
      const waveLength = startLeft * 0.95 * (currentAngle / 270);

      let pathData1 = `M ${startLeft} ${yOffset}`;
      let pathData2 = `M ${startRight} ${yOffset}`;

      // Bucle único para generar los puntos de la onda
      for (let x = 0; x <= waveLength; x++) {
        const mainWave = Math.sin(x * frequency) * totalAmplitude;
        const vibrato =
          Math.sin(x * vibratoFrequency) * currentVibratoAmplitude;
        const y = yOffset + mainWave + vibrato;

        // Añadimos el punto a la onda izquierda (hacia la izquierda)
        pathData1 += ` L ${startLeft - x} ${y}`;
        // Añadimos el punto a la onda derecha (hacia la derecha)
        pathData2 += ` L ${startRight + x} ${y}`;
      }

      sinePath1.setAttribute("d", pathData1);
      sinePath2.setAttribute("d", pathData2);
    }

    function decayPeak() {
      if (peakAmplitude > 0) {
        peakAmplitude = Math.max(0, peakAmplitude - 2.5);
        updateSineWaves();
        requestAnimationFrame(decayPeak);
      }
    }

    function initAudioContext() {
      if (window.audioContext) return;
      try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audioContext = new AudioContext();
      } catch (e) {
        console.error("Web Audio API is not supported in this browser", e);
      }
    }

    function setupBlip() {
      if (!window.audioContext || blipOsc) return;
      blipOsc = window.audioContext.createOscillator();
      blipGain = window.audioContext.createGain();
      blipGain.gain.value = 0;
      blipOsc.connect(blipGain).connect(window.audioContext.destination);
      blipOsc.start();
    }

    function playMenuBlip(freq = 440) {
      if (!window.audioContext || !blipOsc || !blipGain) return;
      const audioContext = window.audioContext;
      blipOsc.frequency.cancelScheduledValues(audioContext.currentTime);
      blipOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
      blipGain.gain.cancelScheduledValues(audioContext.currentTime);
      blipGain.gain.setValueAtTime(0.2, audioContext.currentTime);
      blipGain.gain.exponentialRampToValueAtTime(
        0.001,
        audioContext.currentTime + 0.2
      );
    }

    function playMenuBlip(freq = 440) {
      if (!window.audioContext || !blipOsc || !blipGain) return;
      const audioContext = window.audioContext;
      blipOsc.frequency.cancelScheduledValues(audioContext.currentTime);
      blipOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
      blipGain.gain.cancelScheduledValues(audioContext.currentTime);
      blipGain.gain.setValueAtTime(0.2, audioContext.currentTime);
      blipGain.gain.exponentialRampToValueAtTime(
        0.001,
        audioContext.currentTime + 0.2
      );
    }

    // --- Knob Logic ---
    const knob = document.getElementById("nav-knob");
    if (knob) {
      const knobCenter = knob.querySelector(
        ".knob-center"
      ) as HTMLElement | null;
      const knobRing = knob.querySelector(".knob-ring") as HTMLElement | null;
      const menuTitleDisplay = document.getElementById(
        "menu-title-display"
      ) as HTMLElement | null;
      const menuItems = [
        { nameKey: "nav.home", path: "/gl/", freq: 261.63 },
        { nameKey: "nav.modules", path: "/gl/modulos", freq: 329.63 },
        { nameKey: "nav.demos", path: "/gl/demos", freq: 392.0 },
        { nameKey: "nav.support", path: "/gl/soporte", freq: 440.0 },
      ];
      let isDraggingKnob = false,
        startY = 0,
        lastAngle = 0,
        selectedIndex = 0;

      function updateMenu() {
        const totalItems = menuItems.length;
        const anglePerItem = 270 / (totalItems - 1);
        const newIndex = Math.round(currentAngle / anglePerItem);
        if (newIndex !== selectedIndex) {
          playMenuBlip(menuItems[newIndex].freq);
          peakAmplitude = 50;
          decayPeak();
          if (knobCenter) {
            knobCenter.classList.remove("flash"); // Remove to restart animation
            void knobCenter.offsetWidth; // Trigger reflow
            knobCenter.classList.add("flash");
          }
        }
        selectedIndex = newIndex;
        selectedIndex = Math.max(0, Math.min(totalItems - 1, selectedIndex));
        const nameKey = menuItems[selectedIndex].nameKey;
        if (menuTitleDisplay && ui[currentLang] && ui[currentLang][nameKey]) {
          menuTitleDisplay.textContent = ui[currentLang][nameKey];
          menuTitleDisplay.classList.toggle("visible", nameKey !== "nav.home");
        }
      }

      document.addEventListener("language-change", (e: Event) => {
        const customEvent = e as CustomEvent;
        if (customEvent.detail && typeof customEvent.detail.lang === "string") {
          currentLang = customEvent.detail.lang;
          updateMenu();
        }
      });

      knob.addEventListener("mousedown", (e: MouseEvent) => {
        e.preventDefault();
        isDraggingKnob = true;
        startY = e.clientY;
        lastAngle = currentAngle;
        if (window.audioController) window.audioController.startEngine();
        if (!blipOsc) setupBlip();
        if (knobRing) knobRing.style.transition = "none";
      });
      window.addEventListener("mousemove", (e: MouseEvent) => {
        if (!isDraggingKnob) return;
        const deltaY = e.clientY - startY;
        currentAngle = Math.max(0, Math.min(270, lastAngle - deltaY * 1.5));
        if (knobRing) knobRing.style.transform = `rotate(${currentAngle}deg)`;
        updateMenu();
        updateSineWaves();
      });
      window.addEventListener("mouseup", () => {
        if (!isDraggingKnob) return;
        isDraggingKnob = false;
        if (knobRing) knobRing.style.transition = "transform 0.1s linear";
      });
      knob.addEventListener("click", () => {
        if (Math.abs(lastAngle - currentAngle) > 5) return;
        const targetPath = menuItems[selectedIndex].path;
        // Simple navigation is enough now that we handle page loads correctly.
        window.location.href = targetPath;
      });
      updateMenu();
      updateSineWaves();
    }

    // --- Slideshow Logic ---
    const slideshowContainer = document.querySelector(".slideshow-container");
    if (slideshowContainer) {
      const images = slideshowContainer.querySelectorAll(
        ".slideshow-image"
      ) as NodeListOf<HTMLElement>;
      let currentIndex = 0,
        slideshowInterval: ReturnType<typeof setInterval>,
        scale = 1,
        panning = false,
        start = { x: 0, y: 0 },
        transform = { x: 0, y: 0 };
      if (images.length > 0) {
        function applyTransform(element: HTMLElement | null) {
          if (!element) return;
          element.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${scale})`;
        }
        function resetZoomPanState() {
          scale = 1;
          panning = false;
          start = { x: 0, y: 0 };
          transform = { x: 0, y: 0 };
        }
        slideshowContainer.addEventListener("mousedown", (e: MouseEvent) => {
          e.preventDefault();
          panning = true;
          start = { x: e.clientX - transform.x, y: e.clientY - transform.y };
          slideshowContainer.classList.add("grabbing");
        });
        slideshowContainer.addEventListener("mouseup", () => {
          panning = false;
          slideshowContainer.classList.remove("grabbing");
        });
        slideshowContainer.addEventListener("mousemove", (e: MouseEvent) => {
          e.preventDefault();
          if (!panning || scale === 1) return;
          transform.x = e.clientX - start.x;
          transform.y = e.clientY - start.y;
          applyTransform(images[currentIndex]);
        });
        slideshowContainer.addEventListener("wheel", (e: WheelEvent) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          scale = Math.max(1, Math.min(scale + delta, 5));
          if (scale === 1) {
            transform = { x: 0, y: 0 };
          }
          applyTransform(images[currentIndex]);
        });
        function advanceSlide() {
          if (images[currentIndex]) {
            images[currentIndex].style.transform =
              "translate(0px, 0px) scale(1)";
            images[currentIndex].classList.remove("visible");
          }
          resetZoomPanState();
          currentIndex = (currentIndex + 1) % images.length;
          if (images[currentIndex]) {
            images[currentIndex].classList.add("visible");
            applyTransform(images[currentIndex]);
          }
        }
        function startSlideshow() {
          stopSlideshow();
          slideshowInterval = setInterval(advanceSlide, 3000);
        }
        function stopSlideshow() {
          clearInterval(slideshowInterval);
        }
        slideshowContainer.addEventListener("mousedown", stopSlideshow);
        slideshowContainer.addEventListener("mouseleave", () => {
          panning = false;
          slideshowContainer.classList.remove("grabbing");
          advanceSlide();
          startSlideshow();
        });
        images.forEach((img, index) => {
          img.classList.toggle("visible", index === 0);
        });
        startSlideshow();
      }
    }
  }

  // --- Astro Page Load Event Listener ---
  // This is the correct way to run scripts with Astro View Transitions.
  // It runs on initial load and after every page navigation.
  document.addEventListener("astro:page-load", initHomePage);
  // Initial call for the very first load without transitions.
  initHomePage();
</script>